# 16장. 힙으로 우선순위 유지하기

# I. 우선순위 큐(Priority Queue)

- 삭제와 접근에 있어 전형적인 큐와 흡사하나 삽입에 있어 정렬된 배열과 비슷한 리스트
- 우선순위 큐 앞에서만 데이터에 접근하고 삭제하되 데이터를 삽입할 때는 데이터를 늘 특정 순서대로 정렬
- 데이터를 삽입할 때 항상 적절한 순서를 유지함
- 데이터는 배열 끝에서만 삭제
- 삭제 → O(1), 삽입 → O(N)

# II. 힙(Heap)

## 1. 개요

- 이진 힙(Binary Heap) : 특수한 종류의 이진 트리
- 힙 조건(Heap Condition) : 각 노드의 값은 그 노드의 모든 자손 노드의 값보다 커야 함
- 트리는 완전해야 함

## 2. 힙 조건

- 각 노드의 값이 그 노드의 모든 자손 노드보다 커야함
- 이진 탐색 트리로는 힙을 만들 수 없음
- 최소 힙 : 각 노드가 자손보다 작은 값을 갖도록 힙 구성
- 최대 힙 : 각 노드가 그 노드의 모든 자손 노드보다 큼

## 3. 완전 트리(Complete Tree)

- 빠진 노드 없이 노드가 완전히 채워진 트리
- 각 레벨을 왼쪽부터 오른쪽으로 읽었을 때 모든 자리마다 노드가 있어야 함(바닥 줄에는 빈 자리 가능)

# III. 힙 속성

- 힙은 이진 탐색 트리에 비해 약한 정렬(Weaklt Ordered)
- 힙에는 자손이 조상보다 클 수 없다는 분명한 순서가 있지만 값을 검색하기에는 부족
- 마지막 노드(Last Node) : 바닥 레벨에서 가장 오른쪽에 있는 노드

# IV. 힙 삽입

1. 새 값을 포함하는 노드를 생성하고 바닥 레벨의 가장 오른쪽 노드 옆에 삽입 → 마지막 노드
2. 이어서 새로 삽입한 노드와 그 부모 노드를 비교
3. 새 노드가 부모 노드보다 크면 새 노드와 부모 노드를 스왑
4. 새 노드보다 큰 부모 노드를 만날 때까지 3단계 반복 → 새 노드를 힙 위로 올림
- 트리클링(Trickling) : 새 노드를 힙 위로 올리는 과정
- O(logN)

# V. 마지막 노드 탐색

- 힙의 마지막 노드는 모든 노드를 검사하지 않고는 효율적으로 찾을 수 없음

# VI. 힙 삭제

1. 마지막 노드를 루트 노드 자리로 옮김 → 결과적으로 원래 루트 노드는 삭제
2. 루트 노드를 적절한 자리까지 아래로 트리클링
    1. 트리클 노드의 두 자식을 확인해 어느 쪽이 더 큰지 확인
    2. 트리클 노드가 두 자식 노드 중 큰 노드보다 작으면 큰 노드와 트리클 노드를 스왑
    3. 트리클 노드에 그 노드보다 큰 자식이 없을 때까지 1, 2단계 반복
- O(logN)

# VII. 힙 대 정렬된 배열

|  | 정렬된 배열 | 힙 |
| --- | --- | --- |
| 삽입 | O(N) | O(logN) |
| 삭제 | O(1) | o(logN) |

|  | 정렬된 배열 | 힙 |
| --- | --- | --- |
| 삽입 | 느림 | 매우 빠름 |
| 삭제 | 엄청나게 빠름 | 매우 빠름 |

# VIII. 다시 살펴보는 마지막 노드 문제

- 힙에서는 완정성이 중요함 → 균형 잡힌 힙으로 유지하기 위함
- 불균형이 심한 트리 → O(N)

# IX. 배열로 힙 구현하기

- 마지막 노드 찾기 : 힙 연산의 핵심, 효율적으로 찾아야 함
- 배열로 힙 구현 → 마지막 노드는 항상 배열의 마지막 원소
- 어떤 노드의 왼쪽 자식을 찾으려면 (index * 2) + 1 공식 사용
- 어떤 노드의 오른쪽 자식을 찾으려면 (index * 2) + 2 공식 사용
- 어떤 노드의 부모를 찾으려면 (index - 2) / 2 공식 사용

# X. 우선순위 큐로 쓰이는 힙

- 가장 높은 우선순위를 갖는 항목이 항상 루트 노드에 있음 → 바로 접근 가능
- 가장 높은 우선순위의 항목을 처리할 때마다 다음으로 높은 우선순위의 항목이 힙 꼭대기로 오면서 다음으로 처리할 준비를 함
- O(logN)