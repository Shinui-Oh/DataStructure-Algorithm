# 14장. 노드 기반 자료 구조

# I. 연결 리스트(Linked List)

- 배열과 마찬가지로 항목의 리스트를 표현하는 자료 구조
- 연결 리스트 내 데이터는 연속된 메모리 블록이 아니라 컴퓨터 메모리 전체에 걸쳐 여러 셀에 퍼져 있을 수 있음
- 노드(Node) : 메모리에 곳곳에 흩어진 연결된 데이터
- 링크(Link) : 다음 노드의 메모리 주소로의 포인터
- 헤드(Head) : 연결 리스트의 첫 번째 노드
- 테일(Tail) : 연결 리스트의 마지막 노드

# II. 연결 리스트 구현

- next_node 메서드 : 노드의 링크 역할
- 첫 번째 노드에만 즉시 접근 가능

# III. 읽기

- 프로그램은 연결 리스트의 첫 번째 노드의 메모리 주소만 알고 있음
- O(N)

# IV. 검색

- 첫 번째 노드에서 시작 → 찾고 있는 값을 찾을 때까지 매 값을 검사
- O(N)

# V. 삽입

- 데이터를 연결 리스트 내 어디에 삽입하든 딱 한 단계만 걸림 → O(1)
- 최악의 시나리오 : O(N)

| 시나리오 | 배열 | 연결 리스트 |
| --- | --- | --- |
|  앞에 삽입 | 최악의 경우 | 최선의 경우 |
| 중간에 삽입 | 평균적인 경우 | 평균적인 경우 |
| 끝에 삽입 | 최선의 경우 | 최악의 경우 |

# VI. 삭제

- O(N)

| 상황 | 배열 | 연결 리스트 |
| --- | --- | --- |
| 앞에서 삭제 | 최악의 경우 | 최선의 경우 |
| 중간에서 삭제 | 평균적인 경우 | 평균적인 경우 |
| 끝에서 삭제 | 최선의 경우 | 최악의 경우 |

# VII. 연결 리스트 연산의 효율성

| 연산 | 배열 | 연결 리스트 |
| --- | --- | --- |
| 읽기 | O(1) | O(N) |
| 검색 | O(N) | O(N) |
| 삽입 | O(N)(끝에서 하면 O(1)) | O(N)(앞에서 하면 O(1)) |
| 삭제 | O(N)(끝에서 하면 O(1)) | O(N)(앞에서 하면 O(1)) |

# VIII. 연결 리스트 다루기

- 한 리스트를 검사해서 많은 원소를 삭제할 때
- 삽입이나 삭제 시 다른 데이터를 시프트하지 않아도 됨 → 전체 리스트를 훑으며 삽입이나 삭제를 수행하기에 좋음
- O(N)

# IX. 이중 연결 리스트(Doubly Linked List)

- 각 노드에 2개의 링크가 있다는 점만 제외하면 연결 리스트와 비슷함
- 한 링크는 다음 노드를 가리키고, 다른 한 링크는 앞 노드를 가리킴
- 첫 번째 노드 외에 마지막 노드도 항상 기록
- 리스트 끝에서의 읽기, 삽입, 삭제 모두 O(1)
- 리스트의 앞과 뒤 모두 이동 가능

# X. 이중 연결 리스트 기반 큐

- 양 끝에 데이터를 삽입하거나 삭제 → O(1)
- 끝에서 삽입, 앞에서 삭제 → O(1)로 해결 가능