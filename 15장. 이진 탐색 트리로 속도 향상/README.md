# 15장. 이진 탐색 트리로 속도 향상

# I. 트리(Tree)

- 루트(Root) : 가장 상위 노드, 전형적으로 트리를 묘사하는 방식
- 부모(Parent) : 자식 트리의 상위 노드
- 자손(Descendant) : 그 노드에서 생겨난 모든 노드
- 조상(Ancestor) : 그 노드를 생겨나게 한 모든 노드
- 레벨(Level) : 트리에서 같은 줄
- 프로퍼티(Property) : 균형 잡힌 정도, 균형 트리(Balanced, 모든 노드에서 하위 트리의 노드 개수가 같은 것, 불균형 트리(Imbalanced)

# II. 이진 탐색 트리(Binary Search Tree)

- 이진 트리 : 각 노드에 자식이 0개나 1개, 2개
- 이진 탐색 트리 : 각 노드의 자식은 최대 왼쪽에 하나, 오른쪽에 하나, 한 노드의 왼쪽 자손은 그 노드보다 작은 값만 포함 가능, 오른쪽 자손은 그 노드보다 큰 값만 포함

# III. 검색

## 1. 검색 순서

1. 노드를 ‘현재 노드’로 지정
2. 현재 노드의 값 확인
3. 찾고 있는 값이 현재 노드보다 작으면 왼쪽 하위 트리 검색
4. 찾고 있는 값이 현재 노드보다 크면 오른쪽 하위 트리 검색
5. 찾고 있는 값을 찾았거나 트리 바닥에 닿을 때까지 1~4단계 반복

## 2. 이진 탐색 트리 검색의 효율성

- 루트의 왼쪽/오른쪽 자식을 검색하기로 결정하는 순간 반대편의 자식과 그 자식의 모든 자손은 검색에서 제외
- O(logN)
- 레벨을 새로 추가할 때마다 트리 크기가 두 배가 됨 → 노드가 N개인 트리에서 모든 자리마다 노드를 두려면 log(N) 레벨이 필요

# IV. 삽입

- 검색과 삽입 → log(N) + 1
- O(logN)
- 무작위로 정렬된 데이터 → 균형 잡힌 트리 생성
- 정렬된 데이터 → 불균형 심함, 덜 효율적인 트리 생성

# V. 삭제

- 삭제할 노드에 자식이 없으면 그냥 삭제
- 삭제할 노드에 자식이 하나면 노드 삭제 → 그 자식을 삭제된 노드가 있던 위치에 넣음
- 자식이 둘인 노드를 삭제할 때는 삭제된 노드를 후속자(Successor, 삭제된 노드보다 큰 값 중 최솟값을 갖는 자식 노드) 노드로 대체
- 삭제된 값의 오른쪽 자식을 방문해서 그 자식의 왼쪽 자식을 따라 계속해서 방문하며 더 이상 왼쪽 자식이 없을 때까지 내려감 → 바닥 값이 후속자 노드
- 후속자 노드에 오른쪽 자식이 있으면 후속자 노드를 삭제된 노드가 있던 자리에 넣은 후, 후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣음
- O(logN)

# VI. 이진 탐색 트리 순회

- 트리의 노드를 모두 빠짐없이 방문할 수 있어야 함 → 노드에 접근한다는 뜻
- 순회(Traversal) : 모든 노드를 방문하는 과정
- 리스트를 순서대로 출력할 수 있도록 트리를 알파벳 오름차순으로 순회
- 중위 순회(Inorder Traversal)

```python
def traverse_and_print(node):
	if node is None:
		return

	traverse_and_print(node.leftChild)

	print(node.value)

	traverse_and_print(node.rightChild)
```