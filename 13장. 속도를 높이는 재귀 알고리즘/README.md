# 13장. 속도를 높이는 재귀 알고리즘

# I. 분할(Partition)

## 1. 개요

- 배열로부터 임의의 수(피벗, Pivot)을 가져와 피벗보다 작은 모든 수는 피벗의 왼쪽에, 피벗보다 큰 모든 수는 피벗의 오른쪽에 두는 것

## 2. 분할 순서

1. 두 포인터를 사용해 하나는 배열 가장 왼쪽에 있는 값에, 다른 하나는 피벗을 제외한 배열 가장 오른쪽에 있는 값에 할당
2. 왼쪽 포인터를 한 셀씩 계속 오른쪽으로 옮기면서 피벗보다 크거나 같은 값에 도달하면 멈춤
3. 이어서 오른쪽 포인터를 한 셀씩 계속 왼쪽으로 옮기면서 피벗보다 작거나 같은 값에 도달하면 멈춤, 또는 배열 맨 앞에 도달해도 멈춤
4. 오른쪽 포인터가 멈춘 후에는 둘 중 하나를 선택 → 왼쪽 포인터가 오른쪽 포인터레 도달했으면 5단계로 넘어감, 그렇지 않으면 왼쪽 포인터와 오른쪽 포인터가 가리키고 있는 값을 교환한 후 1~3단계 반복
5. 끝으로 왼쪽 포인터가 현재 가리키고 있는 값과 피벗 교환

# II. 퀵 정렬

1. 배열 분할 → 피벗은 올바른 위치에 있음
2. 피벗의 왼쪽과 오른쪽에 있는 하위 배열을 각각 또 다른 배열로 보고 1~2단계를 재귀적으로 반복 → 각 하위 배열을 분할하고 각 하위 배열에 있는 피벗의 왼쪽과 오른쪽에서 더 작아진 하위 배열을 얻음, 이러한 하위 배열을 다시 분할
3. 하위 배열이 원소를 0개 또는 1개 포함하면 기저 조건 → 아무것도 하지 않음

# III. 퀵 정렬의 효율성

- 비교 : 각 값과 피벗 교환 → N번
- 교환 : 적절한 때에 왼쪽과 오른쪽 포인터가 가리키고 있는 값 교환 → N / 2번
- 한 번 분할 → O(N)

| N | 퀵 정렬 단계 수(근사치) |
| --- | --- |
| 4 | 8 |
| 8 | 24 |
| 16 | 64 |
| 32 | 160 |

| N | logN | NlogN | 퀵 정렬 단계 수(근사치) |
| --- | --- | --- | --- |
| 4 | 2 | 8 | 8 |
| 8 | 3 | 24 | 24 |
| 16 | 4 | 64 | 64 |
| 32 | 5 | 160 | 160 |
- 퀵 정렬 : O(NlogN)

# IV. 퀵 정렬의 최악의 시나리오

- 최선의 시나리오 : 분할 후 피벗이 하위 배열의 한가운데 있는 것
- 최악의 시나리오 : 피벗이 항상 하위 배열의 정중앙이 아닌 한쪽 끝에 있을 때 → 배열이 완전히 오름차순 또는 내림차순

|  | 최선의 경우 | 평균적인 경우 | 최악의 경우 |
| --- | --- | --- | --- |
| 삽입 정렬 | O(N) | O(N^2) | O(N^2) |
| 퀵 정렬 | O(NlogN) | O(NlogN) | O(N^2) |

# V. 퀵 셀렉트(Quick Select)

- 분할에 기반, 퀵 정렬과 이진 검색의 하이브리드 정도
- 전체 배열을 정렬하지 않고도 올바른 값을 찾을 수 있음
- O(N)

# VI. 다른 알고리즘의 핵심 역할을 하는 정렬

- 가장 빠른 정렬 알고리즘 속도 : O(NlogN)
- 병합 정렬(Merge Sort) : O(NlogN)